# 栈的定义

栈是仅在表尾进行压入和弹出元素的线性表

栈满足先进后出（FILO）的容器



# 栈的相关结构

## 栈的数据空间起始地址

即指向栈的指针data

## 栈用到哪里

栈顶指针top

## 栈的容量

int size



# 栈的初始化和释放

## 初始化

```c
typedef struct Stack {
    int *data; //栈数据域指针
    int top; //栈顶元素位置
    int size; //栈容量
} Stack;

Stack *initStack(int n) {
    Stack *st = (Stack *) malloc(sizeof(Stack)); //为栈动态申请堆区内存
    st -> data = (int *) malloc(sizeof(int) * n); //为栈内数据区域动态申请堆区内存
    st -> top = -1; //栈内没有元素时top为-1的位置
    st -> size = n; //容量初始化为n
    return st;
}
```

## 释放

```c
void freeStack(Stack **saddr) { //引用传递，使子函数可以操作主函数中的内容
    if (!(*saddr)) return;
    free((*saddr) -> data); //先释放数据域
    free((*saddr)); //再释放栈本身
    *saddr = NULL; //指向栈的指针置空
    return;
}
```



# 栈的操作

## 压入操作

栈只能从栈顶压入元素

- 栈是否存在
- 栈是否已经装满了，top == size - 1时就说明栈已经装满了
- 栈是否为空的，top == -1时说明栈是空的
- 压入元素时，先让top自增，再将元素放入top处

```c
int push(Stack *s, int val) {
    if (!s) return 0;
    if (s -> top == s -> size - 1) return 0;
    s -> data[++s -> top] = val;
    return 1;
}
```

## 弹出操作

栈只能从栈顶弹出元素

- 栈是否存在
- 栈是否为空
- 栈不为空时将top处的元素取出返回，并将top自减

```c
int isEmpty(Stack *s) {
    //return !s || s -> top == -1;
    return !(s && s -> top != -1);
}

int pop(Stack *s) {
    return s -> data[s -> top--];
}
```

在使用pop函数弹出栈顶元素之前先要用isEmpty函数判断栈是否为空，如果为空就不必调用pop了

栈本身不存在或栈中没有元素时栈为空

## 扩容操作

使用realloc实现连续内存的扩展，如果realloc返回非空就说明扩容成功

```c
int expend(Stack *s) {
    if (!s) return 0;
    int expendsize = s -> size;
    int *tmp = NULL;
    while(expendsize) {
        tmp = (int *) realloc(s -> data,  sizeof(int) * (s -> size + expendsize));
        if (tmp) break;
        expendsize >>= 1; //缩减扩容大小
    }
    if (!tmp) return 0;
    s -> data = tmp; //由于扩容过程可能将现有数据复制到新的地址，所以用realloc的返回值更新一下data指针
    s -> size += expendsize; //更新栈的容量
    printf("expend success, new size is %d\n", s -> size);
    return 1;
}
```



# 使用链表实现栈

考虑push 和 pop的时间复杂度，push 和 pop都对链表的头节点操作

## 初始化和释放

由于要用链表实现栈，所以需要先定义节点的初始化和释放，然后再定义栈的

```c
//节点结构体定义
typedef struct Node {
    int val;
    struct Node *next;
} Node;

//栈结构体定义
typedef struct Stack {
    Node *head;
    int len;
} Stack; //用链表实现的栈没有容量的概念，因为内存不连续，不需要扩容操作

//节点初始化
Node *initNode(int val) {
    Node *n = (Node *) malloc(sizeof(Node));
    if (n) {
        n -> val = val;
        n -> next = NULL;
    }
    return n;
}

//节点释放
void freeNode(Node *p) {
    if (!p) return;
    free(p);
    return;
} 

//栈初始化
Stack *initStack() {
    Stack *s = (Stack *) malloc(sizeof(Stack));
    s -> head = NULL;
    s -> len = 0;
    return s;
}

//栈释放
void freeStack(Stack *s) {
    if (!s) return;
    Node *p = s -> head;
    Node *k = NULL;
    while (p) {
        k = p;
        p = p -> next;
        freeNode(k);
    }
    free(s);
    return;
}
```

## 链表实现栈的操作

### 压栈

使用链表的头插法实现，新节点都插到头部

```c
int push(Stack *s, int val) {
    if (!s) return 0;
    Node *n = initNode(val);
    if (!n) return 0;
    n -> next = s -> head;
    s -> head = n;
    s -> len++;
    return 1;
}
```

### 弹栈

pop函数无法对空栈操作，所以在调用pop之前要先用isEmpty函数判断栈是否为空

```c
int isEmpty(Stack *s) {
    return !(s && s -> head); 
}

int pop(Stack *s) {
    Node *k = s -> head;
    int ret = k -> val;
    s -> head = s -> head -> next;
    freeNode(k);
    return ret;
}
```

## 整体代码

```c
#include<stdio.h>
#include<stdlib.h>
#include<time.h>

typedef struct Node {
    int val;
    struct Node *next;
} Node;

typedef struct Stack {
    Node *head;
    int len;
} Stack;

Node *initNode(int val) {
    Node *n = (Node *) malloc(sizeof(Node));
    if (n) {
        n -> val = val;
        n -> next = NULL;
    }
    return n;
}

void freeNode(Node *p) {
    if (!p) return;
    free(p);
    return;
} 

Stack *initStack() {
    Stack *s = (Stack *) malloc(sizeof(Stack));
    s -> head = NULL;
    s -> len = 0;
    return s;
}

void freeStack(Stack *s) {
    if (!s) return;
    Node *p = s -> head;
    Node *k = NULL;
    while (p) {
        k = p;
        p = p -> next;
        freeNode(k);
    }
    free(s);
    return;
}

int push(Stack *s, int val) {
    if (!s) return 0;
    Node *n = initNode(val);
    if (!n) return 0;
    n -> next = s -> head;
    s -> head = n;
    s -> len++;
    return 1;
}

int isEmpty(Stack *s) {
    return !(s && s -> head); 
}

int pop(Stack *s) {
    Node *k = s -> head;
    int ret = k -> val;
    s -> head = s -> head -> next;
    freeNode(k);
    s -> len--;
    return ret;
}

void showStack(Stack *s) {
    if (!s) return;
    printf("Stack:[");
    Node *p = s -> head;
    while (p) {
        printf("%d -> ", p -> val);
        p = p -> next;
    }
    printf("NULL]\n");
}

int main() {
    srand(time(0));
    Stack *s = initStack(5);
    int cnt = 20;
    while (cnt--) {
        int val = rand() % 100;
        int opt = rand() % 4;
        switch (opt) {
            case 0:
            case 1:
            case 2:
                printf("push %d, res = %s\n", val, push(s, val) ? "SUC" : "ERR");
                break;
            case 3:
                isEmpty(s) ? printf("pop nothing\n") : printf("pop %d\n", pop(s));
                break;
        }
        showStack(s);
    }
    freeStack(s);
    return 0;
}
```

