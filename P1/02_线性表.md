# 线性表的定义

线性表是具有**相同数据类型**的n（n>=0）个数据元素的**有限序列**



# 物理存储结构

在物理内存中线性表是一段**地址连续**的存储单元



# 线性表初始化及释放

## 线性表结构声明

```c
typedef struct Vector{
    int *data; //数组的数据
    int size; //数组的大小
    int len; //数组中元素个数
} Vec;
```

## 线性表初始化

线性表头和其中的数据域，都需要通过malloc动态向堆区申请内存

```c
Vec *init(int n) {
    Vec *v = (Vec *) malloc(sizeof(Vec)); //从堆区申请指向线性表的指针
    v -> data = (int *) malloc(sizeof(int) * n); //从堆区申请线性表数据的指针
    v -> size = n;
    v -> len = 0;
    return v;
}
```

## 线性表的释放

```c
void freeVec(Vec *v) {
    if (v) { //使用free释放内存是要确保传入的指针不为空，否则会报错
        free(v -> data); //要先将数据指针释放掉，然后再释放线性表指针
        free(v);
    }
    printf("free Vector successfully\n");
    return;
}
```



# 线性表操作

## 插入操作

由于线性表在内存上是连续的地址空间，所以插入操作需要将插入点及后面的数据向后移位，并更新len

```c
int insert(Vec *v, int index, int val) {
    if (!v) return 0; //线性表不存在
    if (index < 0 || index > v -> len) return 0; //插入的index不合法
    if (v -> len == v -> size) return 0; //当前数据个数已经达到上限
    memcpy(v -> data + index, v -> data + index + 1, sizeof(int)*(v -> len - index)); //mencpy(dest*, src*, size_t n)，从src拷贝n字节的内容到dest
    v -> data[index] = val; //将val写入插入点index
    v -> len++; //更新元素个数
    return 1;
}
```

## 删除操作

同理，删除节点操作需要将删除点之后的数据前移，并更新数据个数

```c
int erase(Vec *v, int index) {
    if (!v) return 0; //线性表不存在
    if (index < 0 || index >= v -> len) return 0; //index越界（注意len）
    memcpy(v -> data + index, v -> data + index + 1, sizeof(int) * (v -> len - index - 1));
    v -> len--; //更新元素个数
    return 1;
}
```

## 扩容操作

```c
int expend(Vec *v) {
    if (!v) return 0;
    int expsize = v -> size; //初次扩容尝试将容量扩大一倍
    int *tmp;
    while (expsize) {
        tmp = (int *)realloc(v -> data, sizeof(int) * (v -> size + expsize)); //用realloc函数返回值判断是否扩容成功
        if (tmp) break; //relloc函数返回非零说明扩容成功，跳出循环
        expsize >>= 2; //否则尝试将扩容的大小减半
    }
    if (!tmp) {
        printf("expend failed\n");
        return 0;
    }
    v -> size += expsize;
    printf("expend successfully\n");
    return 1;
}
```

- realloc函数返回的值如果为空则说明扩容失败，这时需要减少扩容的大小，再次尝试
- 在insert操作中，当len = size时说明容量已满，此时要先扩容然后再插入



# 主函数

初始化一个线性表，然后随机生成操作状态，随机生成下标index，随机生成值val，基于操作状态进行插入或删除操作，并在每次操作后打印数组

```c
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<time.h>

typedef struct Vector{
    int *data;
    int size;
    int len;
} Vec;

Vec *init(int n) {
    Vec *v = (Vec *) malloc(sizeof(Vec));
    v -> data = (int*) malloc(sizeof(int) * n);
    v -> size = n;
    v -> len = 0;
    printf("init Vector successfully, size is %d\n", v -> size);
    return v;
}

void freeVec(Vec *v) {
    if (v) {
        free(v -> data);
        free(v);
    }
    printf("free Vector successfully\n");
    return;
}

int expend(Vec *v); 

int insert(Vec *v, int index, int val) {
    if (!v) return 0; //线性表不存在
    if (index < 0 || index > v -> len) return 0; //插入的index不合法
    if (v -> len = v -> size) {
        if (!expend(v)) {
            return 0;
        }
    } //当前数据个数已经达到上限
    memcpy(v -> data + index + 1, v -> data + index, sizeof(int) * (v -> len - index));
    v -> data[index] = val;
    v -> len++;
    return 1;
}

int erase(Vec *v, int index) {
    if (!v) return 0;
    if (index < 0 || index >= v -> len) return 0;
    memcpy(v -> data + index, v -> data + index + 1, sizeof(int) * (v -> len - index - 1));
    v -> len--;
    return 1;
}

void showVec(Vec *v) {
    if (!v) return;
    printf("Vec:[");
    for (int i = 0; i < v -> len; ++i) {
        i == 0 || printf(" ");
        printf("%d", v -> data[i]);
    }
    printf("]\n");
}

int expend(Vec *v) {
    if (!v) return 0;
    int expsize = v -> size;
    int *tmp;
    while (expsize) {
        tmp = (int *)realloc(v -> data, sizeof(int) * (v -> size + expsize));
        if (tmp) break;
        expsize >>= 2;
    }
    if (!tmp) {
        printf("expend failed\n");
        return 0;
    }
    v -> size += expsize;
    printf("expend successfully\n");
    return 1;
}

int main() {
    Vec *v = init(1);
    int cnt = 20;
    srand(time(0)); //生成随机数种子
    while (cnt--) {
        int val = rand() % 100;
        int op = rand() % 4;
        int index = rand() % (v -> len + 3) - 1; //index的随机生成要考虑所有越界情况，确保测试完整性

        switch (op) {
            case 0: //用于提高insert概率
            case 1: //用于提高insert概率
            case 2:
                printf("insert %d at %d, res = %d\n", val, index, insert(v, index, val));
                break;
            case 3:
                printf("erase at %d, res = %d\n", index, erase(v, index));
                break;
        }
        showVec(v);
    }

    freeVec(v);
    return 0;
}
```

